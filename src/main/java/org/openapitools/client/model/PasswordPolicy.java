/*
 * AWS Identity and Access Management
 * <fullname>Identity and Access Management</fullname> <p>Identity and Access Management (IAM) is a web service for securely controlling access to Amazon Web Services services. With IAM, you can centrally manage users, security credentials such as access keys, and permissions that control which Amazon Web Services resources users and applications can access. For more information about IAM, see <a href=\"http://aws.amazon.com/iam/\">Identity and Access Management (IAM)</a> and the <a href=\"https://docs.aws.amazon.com/IAM/latest/UserGuide/\">Identity and Access Management User Guide</a>.</p>
 *
 * The version of the OpenAPI document: 2010-05-08
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &lt;p&gt;Contains information about the account password policy.&lt;/p&gt; &lt;p&gt; This data type is used as a response element in the &lt;a&gt;GetAccountPasswordPolicy&lt;/a&gt; operation. &lt;/p&gt;
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T14:26:34.090256+05:30[Asia/Kolkata]", comments = "Generator version: 7.15.0")
public class PasswordPolicy {
  public static final String SERIALIZED_NAME_MINIMUM_PASSWORD_LENGTH = "MinimumPasswordLength";
  @SerializedName(SERIALIZED_NAME_MINIMUM_PASSWORD_LENGTH)
  @javax.annotation.Nullable
  private Integer minimumPasswordLength;

  public static final String SERIALIZED_NAME_REQUIRE_SYMBOLS = "RequireSymbols";
  @SerializedName(SERIALIZED_NAME_REQUIRE_SYMBOLS)
  @javax.annotation.Nullable
  private Boolean requireSymbols;

  public static final String SERIALIZED_NAME_REQUIRE_NUMBERS = "RequireNumbers";
  @SerializedName(SERIALIZED_NAME_REQUIRE_NUMBERS)
  @javax.annotation.Nullable
  private Boolean requireNumbers;

  public static final String SERIALIZED_NAME_REQUIRE_UPPERCASE_CHARACTERS = "RequireUppercaseCharacters";
  @SerializedName(SERIALIZED_NAME_REQUIRE_UPPERCASE_CHARACTERS)
  @javax.annotation.Nullable
  private Boolean requireUppercaseCharacters;

  public static final String SERIALIZED_NAME_REQUIRE_LOWERCASE_CHARACTERS = "RequireLowercaseCharacters";
  @SerializedName(SERIALIZED_NAME_REQUIRE_LOWERCASE_CHARACTERS)
  @javax.annotation.Nullable
  private Boolean requireLowercaseCharacters;

  public static final String SERIALIZED_NAME_ALLOW_USERS_TO_CHANGE_PASSWORD = "AllowUsersToChangePassword";
  @SerializedName(SERIALIZED_NAME_ALLOW_USERS_TO_CHANGE_PASSWORD)
  @javax.annotation.Nullable
  private Boolean allowUsersToChangePassword;

  public static final String SERIALIZED_NAME_EXPIRE_PASSWORDS = "ExpirePasswords";
  @SerializedName(SERIALIZED_NAME_EXPIRE_PASSWORDS)
  @javax.annotation.Nullable
  private Boolean expirePasswords;

  public static final String SERIALIZED_NAME_MAX_PASSWORD_AGE = "MaxPasswordAge";
  @SerializedName(SERIALIZED_NAME_MAX_PASSWORD_AGE)
  @javax.annotation.Nullable
  private Integer maxPasswordAge;

  public static final String SERIALIZED_NAME_PASSWORD_REUSE_PREVENTION = "PasswordReusePrevention";
  @SerializedName(SERIALIZED_NAME_PASSWORD_REUSE_PREVENTION)
  @javax.annotation.Nullable
  private Integer passwordReusePrevention;

  public static final String SERIALIZED_NAME_HARD_EXPIRY = "HardExpiry";
  @SerializedName(SERIALIZED_NAME_HARD_EXPIRY)
  @javax.annotation.Nullable
  private Boolean hardExpiry;

  public PasswordPolicy() {
  }

  public PasswordPolicy minimumPasswordLength(@javax.annotation.Nullable Integer minimumPasswordLength) {
    this.minimumPasswordLength = minimumPasswordLength;
    return this;
  }

  /**
   * Minimum length to require for IAM user passwords.
   * minimum: 6
   * maximum: 128
   * @return minimumPasswordLength
   */
  @javax.annotation.Nullable
  public Integer getMinimumPasswordLength() {
    return minimumPasswordLength;
  }

  public void setMinimumPasswordLength(@javax.annotation.Nullable Integer minimumPasswordLength) {
    this.minimumPasswordLength = minimumPasswordLength;
  }


  public PasswordPolicy requireSymbols(@javax.annotation.Nullable Boolean requireSymbols) {
    this.requireSymbols = requireSymbols;
    return this;
  }

  /**
   * &lt;p&gt;Specifies whether IAM user passwords must contain at least one of the following symbols:&lt;/p&gt; &lt;p&gt;! @ # $ % ^ &amp;amp; * ( ) _ + - &#x3D; [ ] { } | &#39;&lt;/p&gt;
   * @return requireSymbols
   */
  @javax.annotation.Nullable
  public Boolean getRequireSymbols() {
    return requireSymbols;
  }

  public void setRequireSymbols(@javax.annotation.Nullable Boolean requireSymbols) {
    this.requireSymbols = requireSymbols;
  }


  public PasswordPolicy requireNumbers(@javax.annotation.Nullable Boolean requireNumbers) {
    this.requireNumbers = requireNumbers;
    return this;
  }

  /**
   * Specifies whether IAM user passwords must contain at least one numeric character (0 to 9).
   * @return requireNumbers
   */
  @javax.annotation.Nullable
  public Boolean getRequireNumbers() {
    return requireNumbers;
  }

  public void setRequireNumbers(@javax.annotation.Nullable Boolean requireNumbers) {
    this.requireNumbers = requireNumbers;
  }


  public PasswordPolicy requireUppercaseCharacters(@javax.annotation.Nullable Boolean requireUppercaseCharacters) {
    this.requireUppercaseCharacters = requireUppercaseCharacters;
    return this;
  }

  /**
   * Specifies whether IAM user passwords must contain at least one uppercase character (A to Z).
   * @return requireUppercaseCharacters
   */
  @javax.annotation.Nullable
  public Boolean getRequireUppercaseCharacters() {
    return requireUppercaseCharacters;
  }

  public void setRequireUppercaseCharacters(@javax.annotation.Nullable Boolean requireUppercaseCharacters) {
    this.requireUppercaseCharacters = requireUppercaseCharacters;
  }


  public PasswordPolicy requireLowercaseCharacters(@javax.annotation.Nullable Boolean requireLowercaseCharacters) {
    this.requireLowercaseCharacters = requireLowercaseCharacters;
    return this;
  }

  /**
   * Specifies whether IAM user passwords must contain at least one lowercase character (a to z).
   * @return requireLowercaseCharacters
   */
  @javax.annotation.Nullable
  public Boolean getRequireLowercaseCharacters() {
    return requireLowercaseCharacters;
  }

  public void setRequireLowercaseCharacters(@javax.annotation.Nullable Boolean requireLowercaseCharacters) {
    this.requireLowercaseCharacters = requireLowercaseCharacters;
  }


  public PasswordPolicy allowUsersToChangePassword(@javax.annotation.Nullable Boolean allowUsersToChangePassword) {
    this.allowUsersToChangePassword = allowUsersToChangePassword;
    return this;
  }

  /**
   * Specifies whether IAM users are allowed to change their own password. Gives IAM users permissions to &lt;code&gt;iam:ChangePassword&lt;/code&gt; for only their user and to the &lt;code&gt;iam:GetAccountPasswordPolicy&lt;/code&gt; action. This option does not attach a permissions policy to each user, rather the permissions are applied at the account-level for all users by IAM.
   * @return allowUsersToChangePassword
   */
  @javax.annotation.Nullable
  public Boolean getAllowUsersToChangePassword() {
    return allowUsersToChangePassword;
  }

  public void setAllowUsersToChangePassword(@javax.annotation.Nullable Boolean allowUsersToChangePassword) {
    this.allowUsersToChangePassword = allowUsersToChangePassword;
  }


  public PasswordPolicy expirePasswords(@javax.annotation.Nullable Boolean expirePasswords) {
    this.expirePasswords = expirePasswords;
    return this;
  }

  /**
   * Indicates whether passwords in the account expire. Returns true if &lt;code&gt;MaxPasswordAge&lt;/code&gt; contains a value greater than 0. Returns false if MaxPasswordAge is 0 or not present.
   * @return expirePasswords
   */
  @javax.annotation.Nullable
  public Boolean getExpirePasswords() {
    return expirePasswords;
  }

  public void setExpirePasswords(@javax.annotation.Nullable Boolean expirePasswords) {
    this.expirePasswords = expirePasswords;
  }


  public PasswordPolicy maxPasswordAge(@javax.annotation.Nullable Integer maxPasswordAge) {
    this.maxPasswordAge = maxPasswordAge;
    return this;
  }

  /**
   * The number of days that an IAM user password is valid.
   * minimum: 1
   * maximum: 1095
   * @return maxPasswordAge
   */
  @javax.annotation.Nullable
  public Integer getMaxPasswordAge() {
    return maxPasswordAge;
  }

  public void setMaxPasswordAge(@javax.annotation.Nullable Integer maxPasswordAge) {
    this.maxPasswordAge = maxPasswordAge;
  }


  public PasswordPolicy passwordReusePrevention(@javax.annotation.Nullable Integer passwordReusePrevention) {
    this.passwordReusePrevention = passwordReusePrevention;
    return this;
  }

  /**
   * Specifies the number of previous passwords that IAM users are prevented from reusing.
   * minimum: 1
   * maximum: 24
   * @return passwordReusePrevention
   */
  @javax.annotation.Nullable
  public Integer getPasswordReusePrevention() {
    return passwordReusePrevention;
  }

  public void setPasswordReusePrevention(@javax.annotation.Nullable Integer passwordReusePrevention) {
    this.passwordReusePrevention = passwordReusePrevention;
  }


  public PasswordPolicy hardExpiry(@javax.annotation.Nullable Boolean hardExpiry) {
    this.hardExpiry = hardExpiry;
    return this;
  }

  /**
   * Specifies whether IAM users are prevented from setting a new password via the Amazon Web Services Management Console after their password has expired. The IAM user cannot access the console until an administrator resets the password. IAM users with &lt;code&gt;iam:ChangePassword&lt;/code&gt; permission and active access keys can reset their own expired console password using the CLI or API.
   * @return hardExpiry
   */
  @javax.annotation.Nullable
  public Boolean getHardExpiry() {
    return hardExpiry;
  }

  public void setHardExpiry(@javax.annotation.Nullable Boolean hardExpiry) {
    this.hardExpiry = hardExpiry;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PasswordPolicy passwordPolicy = (PasswordPolicy) o;
    return Objects.equals(this.minimumPasswordLength, passwordPolicy.minimumPasswordLength) &&
        Objects.equals(this.requireSymbols, passwordPolicy.requireSymbols) &&
        Objects.equals(this.requireNumbers, passwordPolicy.requireNumbers) &&
        Objects.equals(this.requireUppercaseCharacters, passwordPolicy.requireUppercaseCharacters) &&
        Objects.equals(this.requireLowercaseCharacters, passwordPolicy.requireLowercaseCharacters) &&
        Objects.equals(this.allowUsersToChangePassword, passwordPolicy.allowUsersToChangePassword) &&
        Objects.equals(this.expirePasswords, passwordPolicy.expirePasswords) &&
        Objects.equals(this.maxPasswordAge, passwordPolicy.maxPasswordAge) &&
        Objects.equals(this.passwordReusePrevention, passwordPolicy.passwordReusePrevention) &&
        Objects.equals(this.hardExpiry, passwordPolicy.hardExpiry);
  }

  @Override
  public int hashCode() {
    return Objects.hash(minimumPasswordLength, requireSymbols, requireNumbers, requireUppercaseCharacters, requireLowercaseCharacters, allowUsersToChangePassword, expirePasswords, maxPasswordAge, passwordReusePrevention, hardExpiry);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PasswordPolicy {\n");
    sb.append("    minimumPasswordLength: ").append(toIndentedString(minimumPasswordLength)).append("\n");
    sb.append("    requireSymbols: ").append(toIndentedString(requireSymbols)).append("\n");
    sb.append("    requireNumbers: ").append(toIndentedString(requireNumbers)).append("\n");
    sb.append("    requireUppercaseCharacters: ").append(toIndentedString(requireUppercaseCharacters)).append("\n");
    sb.append("    requireLowercaseCharacters: ").append(toIndentedString(requireLowercaseCharacters)).append("\n");
    sb.append("    allowUsersToChangePassword: ").append(toIndentedString(allowUsersToChangePassword)).append("\n");
    sb.append("    expirePasswords: ").append(toIndentedString(expirePasswords)).append("\n");
    sb.append("    maxPasswordAge: ").append(toIndentedString(maxPasswordAge)).append("\n");
    sb.append("    passwordReusePrevention: ").append(toIndentedString(passwordReusePrevention)).append("\n");
    sb.append("    hardExpiry: ").append(toIndentedString(hardExpiry)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("MinimumPasswordLength", "RequireSymbols", "RequireNumbers", "RequireUppercaseCharacters", "RequireLowercaseCharacters", "AllowUsersToChangePassword", "ExpirePasswords", "MaxPasswordAge", "PasswordReusePrevention", "HardExpiry"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(0);
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PasswordPolicy
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PasswordPolicy.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PasswordPolicy is not found in the empty JSON string", PasswordPolicy.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PasswordPolicy.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PasswordPolicy` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PasswordPolicy.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PasswordPolicy' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PasswordPolicy> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PasswordPolicy.class));

       return (TypeAdapter<T>) new TypeAdapter<PasswordPolicy>() {
           @Override
           public void write(JsonWriter out, PasswordPolicy value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PasswordPolicy read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PasswordPolicy given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PasswordPolicy
   * @throws IOException if the JSON string is invalid with respect to PasswordPolicy
   */
  public static PasswordPolicy fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PasswordPolicy.class);
  }

  /**
   * Convert an instance of PasswordPolicy to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

