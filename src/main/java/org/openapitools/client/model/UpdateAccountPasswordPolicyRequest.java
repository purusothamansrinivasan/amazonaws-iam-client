/*
 * AWS Identity and Access Management
 * <fullname>Identity and Access Management</fullname> <p>Identity and Access Management (IAM) is a web service for securely controlling access to Amazon Web Services services. With IAM, you can centrally manage users, security credentials such as access keys, and permissions that control which Amazon Web Services resources users and applications can access. For more information about IAM, see <a href=\"http://aws.amazon.com/iam/\">Identity and Access Management (IAM)</a> and the <a href=\"https://docs.aws.amazon.com/IAM/latest/UserGuide/\">Identity and Access Management User Guide</a>.</p>
 *
 * The version of the OpenAPI document: 2010-05-08
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * UpdateAccountPasswordPolicyRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T14:26:34.090256+05:30[Asia/Kolkata]", comments = "Generator version: 7.15.0")
public class UpdateAccountPasswordPolicyRequest {
  public static final String SERIALIZED_NAME_MINIMUM_PASSWORD_LENGTH = "MinimumPasswordLength";
  @SerializedName(SERIALIZED_NAME_MINIMUM_PASSWORD_LENGTH)
  @javax.annotation.Nullable
  private Integer minimumPasswordLength;

  public static final String SERIALIZED_NAME_REQUIRE_SYMBOLS = "RequireSymbols";
  @SerializedName(SERIALIZED_NAME_REQUIRE_SYMBOLS)
  @javax.annotation.Nullable
  private Boolean requireSymbols;

  public static final String SERIALIZED_NAME_REQUIRE_NUMBERS = "RequireNumbers";
  @SerializedName(SERIALIZED_NAME_REQUIRE_NUMBERS)
  @javax.annotation.Nullable
  private Boolean requireNumbers;

  public static final String SERIALIZED_NAME_REQUIRE_UPPERCASE_CHARACTERS = "RequireUppercaseCharacters";
  @SerializedName(SERIALIZED_NAME_REQUIRE_UPPERCASE_CHARACTERS)
  @javax.annotation.Nullable
  private Boolean requireUppercaseCharacters;

  public static final String SERIALIZED_NAME_REQUIRE_LOWERCASE_CHARACTERS = "RequireLowercaseCharacters";
  @SerializedName(SERIALIZED_NAME_REQUIRE_LOWERCASE_CHARACTERS)
  @javax.annotation.Nullable
  private Boolean requireLowercaseCharacters;

  public static final String SERIALIZED_NAME_ALLOW_USERS_TO_CHANGE_PASSWORD = "AllowUsersToChangePassword";
  @SerializedName(SERIALIZED_NAME_ALLOW_USERS_TO_CHANGE_PASSWORD)
  @javax.annotation.Nullable
  private Boolean allowUsersToChangePassword;

  public static final String SERIALIZED_NAME_MAX_PASSWORD_AGE = "MaxPasswordAge";
  @SerializedName(SERIALIZED_NAME_MAX_PASSWORD_AGE)
  @javax.annotation.Nullable
  private Integer maxPasswordAge;

  public static final String SERIALIZED_NAME_PASSWORD_REUSE_PREVENTION = "PasswordReusePrevention";
  @SerializedName(SERIALIZED_NAME_PASSWORD_REUSE_PREVENTION)
  @javax.annotation.Nullable
  private Integer passwordReusePrevention;

  public static final String SERIALIZED_NAME_HARD_EXPIRY = "HardExpiry";
  @SerializedName(SERIALIZED_NAME_HARD_EXPIRY)
  @javax.annotation.Nullable
  private Boolean hardExpiry;

  public UpdateAccountPasswordPolicyRequest() {
  }

  public UpdateAccountPasswordPolicyRequest minimumPasswordLength(@javax.annotation.Nullable Integer minimumPasswordLength) {
    this.minimumPasswordLength = minimumPasswordLength;
    return this;
  }

  /**
   * &lt;p&gt;The minimum number of characters allowed in an IAM user password.&lt;/p&gt; &lt;p&gt;If you do not specify a value for this parameter, then the operation uses the default value of &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;
   * minimum: 6
   * maximum: 128
   * @return minimumPasswordLength
   */
  @javax.annotation.Nullable
  public Integer getMinimumPasswordLength() {
    return minimumPasswordLength;
  }

  public void setMinimumPasswordLength(@javax.annotation.Nullable Integer minimumPasswordLength) {
    this.minimumPasswordLength = minimumPasswordLength;
  }


  public UpdateAccountPasswordPolicyRequest requireSymbols(@javax.annotation.Nullable Boolean requireSymbols) {
    this.requireSymbols = requireSymbols;
    return this;
  }

  /**
   * &lt;p&gt;Specifies whether IAM user passwords must contain at least one of the following non-alphanumeric characters:&lt;/p&gt; &lt;p&gt;! @ # $ % ^ &amp;amp; * ( ) _ + - &#x3D; [ ] { } | &#39;&lt;/p&gt; &lt;p&gt;If you do not specify a value for this parameter, then the operation uses the default value of &lt;code&gt;false&lt;/code&gt;. The result is that passwords do not require at least one symbol character.&lt;/p&gt;
   * @return requireSymbols
   */
  @javax.annotation.Nullable
  public Boolean getRequireSymbols() {
    return requireSymbols;
  }

  public void setRequireSymbols(@javax.annotation.Nullable Boolean requireSymbols) {
    this.requireSymbols = requireSymbols;
  }


  public UpdateAccountPasswordPolicyRequest requireNumbers(@javax.annotation.Nullable Boolean requireNumbers) {
    this.requireNumbers = requireNumbers;
    return this;
  }

  /**
   * &lt;p&gt;Specifies whether IAM user passwords must contain at least one numeric character (0 to 9).&lt;/p&gt; &lt;p&gt;If you do not specify a value for this parameter, then the operation uses the default value of &lt;code&gt;false&lt;/code&gt;. The result is that passwords do not require at least one numeric character.&lt;/p&gt;
   * @return requireNumbers
   */
  @javax.annotation.Nullable
  public Boolean getRequireNumbers() {
    return requireNumbers;
  }

  public void setRequireNumbers(@javax.annotation.Nullable Boolean requireNumbers) {
    this.requireNumbers = requireNumbers;
  }


  public UpdateAccountPasswordPolicyRequest requireUppercaseCharacters(@javax.annotation.Nullable Boolean requireUppercaseCharacters) {
    this.requireUppercaseCharacters = requireUppercaseCharacters;
    return this;
  }

  /**
   * &lt;p&gt;Specifies whether IAM user passwords must contain at least one uppercase character from the ISO basic Latin alphabet (A to Z).&lt;/p&gt; &lt;p&gt;If you do not specify a value for this parameter, then the operation uses the default value of &lt;code&gt;false&lt;/code&gt;. The result is that passwords do not require at least one uppercase character.&lt;/p&gt;
   * @return requireUppercaseCharacters
   */
  @javax.annotation.Nullable
  public Boolean getRequireUppercaseCharacters() {
    return requireUppercaseCharacters;
  }

  public void setRequireUppercaseCharacters(@javax.annotation.Nullable Boolean requireUppercaseCharacters) {
    this.requireUppercaseCharacters = requireUppercaseCharacters;
  }


  public UpdateAccountPasswordPolicyRequest requireLowercaseCharacters(@javax.annotation.Nullable Boolean requireLowercaseCharacters) {
    this.requireLowercaseCharacters = requireLowercaseCharacters;
    return this;
  }

  /**
   * &lt;p&gt;Specifies whether IAM user passwords must contain at least one lowercase character from the ISO basic Latin alphabet (a to z).&lt;/p&gt; &lt;p&gt;If you do not specify a value for this parameter, then the operation uses the default value of &lt;code&gt;false&lt;/code&gt;. The result is that passwords do not require at least one lowercase character.&lt;/p&gt;
   * @return requireLowercaseCharacters
   */
  @javax.annotation.Nullable
  public Boolean getRequireLowercaseCharacters() {
    return requireLowercaseCharacters;
  }

  public void setRequireLowercaseCharacters(@javax.annotation.Nullable Boolean requireLowercaseCharacters) {
    this.requireLowercaseCharacters = requireLowercaseCharacters;
  }


  public UpdateAccountPasswordPolicyRequest allowUsersToChangePassword(@javax.annotation.Nullable Boolean allowUsersToChangePassword) {
    this.allowUsersToChangePassword = allowUsersToChangePassword;
    return this;
  }

  /**
   * &lt;p&gt; Allows all IAM users in your account to use the Amazon Web Services Management Console to change their own passwords. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_passwords_enable-user-change.html\&quot;&gt;Permitting IAM users to change their own passwords&lt;/a&gt; in the &lt;i&gt;IAM User Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you do not specify a value for this parameter, then the operation uses the default value of &lt;code&gt;false&lt;/code&gt;. The result is that IAM users in the account do not automatically have permissions to change their own password.&lt;/p&gt;
   * @return allowUsersToChangePassword
   */
  @javax.annotation.Nullable
  public Boolean getAllowUsersToChangePassword() {
    return allowUsersToChangePassword;
  }

  public void setAllowUsersToChangePassword(@javax.annotation.Nullable Boolean allowUsersToChangePassword) {
    this.allowUsersToChangePassword = allowUsersToChangePassword;
  }


  public UpdateAccountPasswordPolicyRequest maxPasswordAge(@javax.annotation.Nullable Integer maxPasswordAge) {
    this.maxPasswordAge = maxPasswordAge;
    return this;
  }

  /**
   * &lt;p&gt;The number of days that an IAM user password is valid.&lt;/p&gt; &lt;p&gt;If you do not specify a value for this parameter, then the operation uses the default value of &lt;code&gt;0&lt;/code&gt;. The result is that IAM user passwords never expire.&lt;/p&gt;
   * minimum: 1
   * maximum: 1095
   * @return maxPasswordAge
   */
  @javax.annotation.Nullable
  public Integer getMaxPasswordAge() {
    return maxPasswordAge;
  }

  public void setMaxPasswordAge(@javax.annotation.Nullable Integer maxPasswordAge) {
    this.maxPasswordAge = maxPasswordAge;
  }


  public UpdateAccountPasswordPolicyRequest passwordReusePrevention(@javax.annotation.Nullable Integer passwordReusePrevention) {
    this.passwordReusePrevention = passwordReusePrevention;
    return this;
  }

  /**
   * &lt;p&gt;Specifies the number of previous passwords that IAM users are prevented from reusing.&lt;/p&gt; &lt;p&gt;If you do not specify a value for this parameter, then the operation uses the default value of &lt;code&gt;0&lt;/code&gt;. The result is that IAM users are not prevented from reusing previous passwords.&lt;/p&gt;
   * minimum: 1
   * maximum: 24
   * @return passwordReusePrevention
   */
  @javax.annotation.Nullable
  public Integer getPasswordReusePrevention() {
    return passwordReusePrevention;
  }

  public void setPasswordReusePrevention(@javax.annotation.Nullable Integer passwordReusePrevention) {
    this.passwordReusePrevention = passwordReusePrevention;
  }


  public UpdateAccountPasswordPolicyRequest hardExpiry(@javax.annotation.Nullable Boolean hardExpiry) {
    this.hardExpiry = hardExpiry;
    return this;
  }

  /**
   * &lt;p&gt; Prevents IAM users who are accessing the account via the Amazon Web Services Management Console from setting a new console password after their password has expired. The IAM user cannot access the console until an administrator resets the password.&lt;/p&gt; &lt;p&gt;If you do not specify a value for this parameter, then the operation uses the default value of &lt;code&gt;false&lt;/code&gt;. The result is that IAM users can change their passwords after they expire and continue to sign in as the user.&lt;/p&gt; &lt;note&gt; &lt;p&gt; In the Amazon Web Services Management Console, the custom password policy option &lt;b&gt;Allow users to change their own password&lt;/b&gt; gives IAM users permissions to &lt;code&gt;iam:ChangePassword&lt;/code&gt; for only their user and to the &lt;code&gt;iam:GetAccountPasswordPolicy&lt;/code&gt; action. This option does not attach a permissions policy to each user, rather the permissions are applied at the account-level for all users by IAM. IAM users with &lt;code&gt;iam:ChangePassword&lt;/code&gt; permission and active access keys can reset their own expired console password using the CLI or API.&lt;/p&gt; &lt;/note&gt;
   * @return hardExpiry
   */
  @javax.annotation.Nullable
  public Boolean getHardExpiry() {
    return hardExpiry;
  }

  public void setHardExpiry(@javax.annotation.Nullable Boolean hardExpiry) {
    this.hardExpiry = hardExpiry;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdateAccountPasswordPolicyRequest updateAccountPasswordPolicyRequest = (UpdateAccountPasswordPolicyRequest) o;
    return Objects.equals(this.minimumPasswordLength, updateAccountPasswordPolicyRequest.minimumPasswordLength) &&
        Objects.equals(this.requireSymbols, updateAccountPasswordPolicyRequest.requireSymbols) &&
        Objects.equals(this.requireNumbers, updateAccountPasswordPolicyRequest.requireNumbers) &&
        Objects.equals(this.requireUppercaseCharacters, updateAccountPasswordPolicyRequest.requireUppercaseCharacters) &&
        Objects.equals(this.requireLowercaseCharacters, updateAccountPasswordPolicyRequest.requireLowercaseCharacters) &&
        Objects.equals(this.allowUsersToChangePassword, updateAccountPasswordPolicyRequest.allowUsersToChangePassword) &&
        Objects.equals(this.maxPasswordAge, updateAccountPasswordPolicyRequest.maxPasswordAge) &&
        Objects.equals(this.passwordReusePrevention, updateAccountPasswordPolicyRequest.passwordReusePrevention) &&
        Objects.equals(this.hardExpiry, updateAccountPasswordPolicyRequest.hardExpiry);
  }

  @Override
  public int hashCode() {
    return Objects.hash(minimumPasswordLength, requireSymbols, requireNumbers, requireUppercaseCharacters, requireLowercaseCharacters, allowUsersToChangePassword, maxPasswordAge, passwordReusePrevention, hardExpiry);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdateAccountPasswordPolicyRequest {\n");
    sb.append("    minimumPasswordLength: ").append(toIndentedString(minimumPasswordLength)).append("\n");
    sb.append("    requireSymbols: ").append(toIndentedString(requireSymbols)).append("\n");
    sb.append("    requireNumbers: ").append(toIndentedString(requireNumbers)).append("\n");
    sb.append("    requireUppercaseCharacters: ").append(toIndentedString(requireUppercaseCharacters)).append("\n");
    sb.append("    requireLowercaseCharacters: ").append(toIndentedString(requireLowercaseCharacters)).append("\n");
    sb.append("    allowUsersToChangePassword: ").append(toIndentedString(allowUsersToChangePassword)).append("\n");
    sb.append("    maxPasswordAge: ").append(toIndentedString(maxPasswordAge)).append("\n");
    sb.append("    passwordReusePrevention: ").append(toIndentedString(passwordReusePrevention)).append("\n");
    sb.append("    hardExpiry: ").append(toIndentedString(hardExpiry)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("MinimumPasswordLength", "RequireSymbols", "RequireNumbers", "RequireUppercaseCharacters", "RequireLowercaseCharacters", "AllowUsersToChangePassword", "MaxPasswordAge", "PasswordReusePrevention", "HardExpiry"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(0);
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UpdateAccountPasswordPolicyRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UpdateAccountPasswordPolicyRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UpdateAccountPasswordPolicyRequest is not found in the empty JSON string", UpdateAccountPasswordPolicyRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UpdateAccountPasswordPolicyRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UpdateAccountPasswordPolicyRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UpdateAccountPasswordPolicyRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UpdateAccountPasswordPolicyRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UpdateAccountPasswordPolicyRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UpdateAccountPasswordPolicyRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<UpdateAccountPasswordPolicyRequest>() {
           @Override
           public void write(JsonWriter out, UpdateAccountPasswordPolicyRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UpdateAccountPasswordPolicyRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UpdateAccountPasswordPolicyRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UpdateAccountPasswordPolicyRequest
   * @throws IOException if the JSON string is invalid with respect to UpdateAccountPasswordPolicyRequest
   */
  public static UpdateAccountPasswordPolicyRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UpdateAccountPasswordPolicyRequest.class);
  }

  /**
   * Convert an instance of UpdateAccountPasswordPolicyRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

